---
unit_title: Vector functions
needs: [manip-basics]
theme: wrangle
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
options(tibble.print_min = 5, tibble.print_max = 5)
library(tidyverse)
```

## Letter grades

It's easy to inadvertently create a __scalar function__, i.e. a function that takes length 1 input and produces length 1. You can always apply a scalar function to a vector of values by using the appropriate purrr `map_` function, but you can often find a more efficient approach by relying on an existing vectorised function.

A common way to create a scalar function is by using a if-else statement. For example, might write the following function that converts a numeric grade to a letter grade:

```{r}
grade <- function(x) {
  if (x >= 90) {
    "A"
  } else if (x >= 80) {
    "B"
  } else if (x >= 70) {
    "C"
  } else if (x >= 60) {
    "D"
  } else {
    "F"
  }
}
```

This works well when applied to single values:

```{r}
grade(92)
grade(76)
grade(60)
```

But fails if you attempt to apply it to an entire column of a data frame:

```{r}
df <- tibble(score = sample(100, 10, replace = TRUE))
df %>% mutate(grade = grade(score))
```

You can always work around this problem using one of the `map_` functions from purrr. In this case, `grade()` returns a character vector so we'd use `map_chr()`:

```{r}
df %>% mutate(grade = map_chr(score, grade))
```

However, there is often an alternative, more elegant approach by relying on an exising vector function. For example, you can always rewrite a set of nested if-else statements to use `case_when()`:

```{r}
grade2 <- function(x) {
  case_when(
    x > 90 ~ "A",
    x > 80 ~ "B",
    x > 70 ~ "C",
    x > 60 ~ "D",
    TRUE ~   "F"
  )
}
grade(seq(0, 100, by = 10))

df %>% mutate(grade = grade2(score))
```

For this particular case, there's an even more targetted function from base R: `cut()`. Its job is to "cut" a number into labelled intervals. You give it a vector of breaks and a vector of labels, and it produces a factor for you:

```{r}
grade3 <- function(x) {
  cut(x, 
    breaks = c(-Inf, 60, 70, 80, 90, Inf), 
    labels = c("F", "D", "C", "B", "A")
  )
}
grade3(seq(0, 100, by = 10))
```

(Note that you supply it one less `label` than `breaks`; if this is confusing, try drawing a picture.)

In general, there's no easy way to find out that there's an existing function that will make your life much easier. The best technique is to continually expand your knowledge of R by reading widely; a good place to start are the weekly highlights on <http://rweekly.org/>.

## Matching many patterns

A similar problem is accidentally using a vectorised function as if it's a scalar function, making life harder for yourself. I'll illustrate the problem with a function that you'll already familiar with `stringr::str_detect()`. So far when you've used stringr, we've always used a single `pattern`. But imagine you have a new challenge: you have a single string and you want see which of a possible set of patterns it matches:

```{r}
private <- tribble(
  ~ name,  ~ pattern,
  "ssn",   "\\d{3}-\\d{2}-\\d{4}",
  "email", "[a-z]+@[a-z]+\\.[a-z]{2,4}",
  "phone", "\\d{3}[- ]?\\d{3}[- ]?\\d{4}"
)

string <- "My social security number is 231-57-7340 and my phone number is 712-458-2189"
```

You might be tempted to use `map_lgl()`:

```{r}
match <- map_lgl(private$pattern, ~ str_detect(string, pattern = .x))
private$name[match]
```

But if you carefully read the documentation for `str_detect()` you'll discover that this is unnecessary because `str_detect()` is vectorised oven `pattern`. That means you don't need `map_lgl()`!

```{r}
private$name[str_detect(string, private$pattern)]
```

It's sometimes hard to tell from the documentation whether or not an argument is vectorised. If reading the docs doesn't help, just try it with a vector; if it works you'll have learned something new and saved yourself a little typing.

