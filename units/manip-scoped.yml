title: Scoped verbs
theme: wrangle
needs:
- iteration
- manip-basics
readings: ~
updated: ~
desc: "\n## dplyr 0.6.0\n\nFirst, make sure you have the latest version of dplyr,
  0.6.0. You can\ncheck what version you currently have with `packageVersion()`:\n\n```
  r\npackageVersion(\"dplyr\")\n#> [1] '0.7.4'\n```\n\n(If you’re using the development
  version, version 0.5.0.9005 is also\nok.)\n\nIf you’re version is older, use `install.packages()`
  to update it.\n\n## Scoped verbs\n\nIn the latest version of dplyr each of the single
  table verbs comes in\nthree additional forms with the suffixes `_if`, `_at`, and
  `_all`. These\n**scoped** variants allow you to affect multiple variables at once:\n\n
  \ - `_if` allows you to pick variables based on a predicate function\n    like `is.numeric()`
  or `is.character()`.\n\n  - `_at` allows you to pick variables using the same syntax
  as\n    `select()`.\n\n  - `_all` operates on all variables.\n\nI’ll illustrate
  the three variants in detail for `summarise()`, then\nexplore in less detail how
  you can use similar techniques with\n`mutate()` and `filter()`. You’ll need the
  scoped variants of the other\nverbs less frequently, but when you do, it should
  be straightforward to\ngeneralise what you’ve learn here.\n\n## Summarise\n\n###
  `summarise_all()`\n\nThe simplest variant to understand is `summarise_all()`. It
  takes a\ntibble and a function and applies that function to each column:\n\n```
  r\ndf <- tibble(\n  x = runif(100),\n  y = runif(100),\n  z = runif(100)\n)\nsummarise_all(df,
  mean)\n#> # A tibble: 1 x 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#>
  1 0.451 0.503 0.485\n```\n\nIf you want to apply multiple summaries, use the `funs()`
  helper:\n\n``` r\nsummarise_all(df, funs(min, max))\n#> # A tibble: 1 x 6\n#>     x_min
  \  y_min   z_min x_max y_max z_max\n#>     <dbl>   <dbl>   <dbl> <dbl> <dbl> <dbl>\n#>
  1 0.00515 0.00685 0.00801 0.998 0.952 0.986\n```\n\nThere are two slightly inconsistent
  ways to use an inline function (this\ninconistency will get ironed out in a future
  version).\n\n``` r\n# For a single function, use ~ \nsummarise_all(df, ~ sd(.) /
  mean(.))\n#> # A tibble: 1 x 3\n#>       x     y     z\n#>   <dbl> <dbl> <dbl>\n#>
  1 0.632 0.567 0.588\n\n# For multiple functions, use funs(), dropping the ~\n# Typically
  you'll want to name the function so you get reasonable\n# variable names.\nsummarise_all(df,
  funs(cv = sd(.) / mean(.), mean))\n#> # A tibble: 1 x 6\n#>    x_cv  y_cv  z_cv
  x_mean y_mean z_mean\n#>   <dbl> <dbl> <dbl>  <dbl>  <dbl>  <dbl>\n#> 1 0.632 0.567
  0.588  0.451  0.503  0.485\n```\n\n### `summarise_at()`\n\n`summarise_at()` allows
  you to pick columns in the same way as\n`select()`, that is, based on their names.
  There is one small\ndifference: you need to wrap the complete selection with the
  `vars()`\nhelper (this avoids ambiguity).\n\n``` r\nsummarise_at(df, vars(-z), mean)\n#>
  # A tibble: 1 x 2\n#>       x     y\n#>   <dbl> <dbl>\n#> 1 0.451 0.503\n```\n\nBy
  default, the newly created columns have the shortest names needed to\nuniquely identify
  the output.\n\n``` r\nsummarise_at(df, vars(x), funs(min, max))\n#> # A tibble:
  1 x 2\n#>       min   max\n#>     <dbl> <dbl>\n#> 1 0.00515 0.998\nsummarise_at(df,
  vars(x, y), min)\n#> # A tibble: 1 x 2\n#>         x       y\n#>     <dbl>   <dbl>\n#>
  1 0.00515 0.00685\nsummarise_at(df, vars(-z), funs(min, max))\n#> # A tibble: 1
  x 4\n#>     x_min   y_min x_max y_max\n#>     <dbl>   <dbl> <dbl> <dbl>\n#> 1 0.00515
  0.00685 0.998 0.952\n```\n\nSee the examples in the documentation if you want to
  force names when\nthey’re not otherwise needed.\n\n### `summarise_if()`\n\n`summarise_at()`
  allows you to pick variables to summarise based on\ntheir name. `summarise_if()`
  allows you to pick variables to summarise\nbased on some property of the column.
  Typically this is their type\nbecause you want to (e.g.) apply a numeric summary
  function only to\nnumeric columns:\n\n``` r\nstarwars %>%\n  group_by(species) %>%\n
  \ summarise_if(is.numeric, mean, na.rm = TRUE)\n#> # A tibble: 38 x 4\n#>   species
  \ height  mass birth_year\n#>   <chr>     <dbl> <dbl>      <dbl>\n#> 1 Aleena     79.0
  \ 15.0      NaN  \n#> 2 Besalisk  198   102        NaN  \n#> 3 Cerean    198    82.0
  \      92.0\n#> 4 Chagrian  196   NaN        NaN  \n#> 5 Clawdite  168    55.0      NaN
  \ \n#> # ... with 33 more rows\n```\n\n(Note that `na.rm = TRUE` is passed on to
  `mean()` in the same way as in\n`purrr::map()`.)\n\n## Mutate\n\n`mutate_all()`,
  `mutate_if()` and `mutate_at()` work in a similar way to\ntheir summarise equivalents.\n\n```
  r\nmutate_all(df, log10)\n#> # A tibble: 100 x 3\n#>         x       y       z\n#>
  \    <dbl>   <dbl>   <dbl>\n#> 1 -0.0826 -0.0477 -0.212 \n#> 2 -1.16   -1.73   -0.145
  \n#> 3 -0.869  -0.301  -0.495 \n#> 4 -0.494  -0.475  -0.444 \n#> 5 -0.0567 -0.123
  \ -0.0624\n#> # ... with 95 more rows\n```\n\nOften you’ll want to use an inline
  expression. As above, either use `~`\nfor a single function or `funs()` for multiple
  functions:\n\n``` r\nmutate_all(df, ~ round(. * 25))\n#> # A tibble: 100 x 3\n#>
  \      x     y     z\n#>   <dbl> <dbl> <dbl>\n#> 1 21.0  22.0  15.0 \n#> 2  2.00
  \ 0    18.0 \n#> 3  3.00 13.0   8.00\n#> 4  8.00  8.00  9.00\n#> 5 22.0  19.0  22.0
  \n#> # ... with 95 more rows\nmutate_all(df, funs(half = . / 2, double = . * 2))\n#>
  # A tibble: 100 x 9\n#>        x      y     z x_half  y_half z_half x_double y_double
  z_double\n#>    <dbl>  <dbl> <dbl>  <dbl>   <dbl>  <dbl>    <dbl>    <dbl>    <dbl>\n#>
  1 0.827  0.896  0.614 0.413  0.448    0.307    1.65    1.79      1.23 \n#> 2 0.0684
  0.0184 0.715 0.0342 0.00921  0.358    0.137   0.0369    1.43 \n#> 3 0.135  0.500
  \ 0.320 0.0676 0.250    0.160    0.270   1.00      0.639\n#> 4 0.320  0.335  0.360
  0.160  0.168    0.180    0.641   0.671     0.720\n#> 5 0.878  0.753  0.866 0.439
  \ 0.376    0.433    1.76    1.51      1.73 \n#> # ... with 95 more rows\n```\n\nThe
  default names are generated in the same way as `summarise()`. That\nmeans that you
  may want to use a `transmute()` variant if you want to\napply multiple transformations
  and don’t want the original values:\n\n``` r\ntransmute_all(df, funs(half = . /
  2, double = . * 2))\n#> # A tibble: 100 x 6\n#>   x_half  y_half z_half x_double
  y_double z_double\n#>    <dbl>   <dbl>  <dbl>    <dbl>    <dbl>    <dbl>\n#> 1 0.413
  \ 0.448    0.307    1.65    1.79      1.23 \n#> 2 0.0342 0.00921  0.358    0.137
  \  0.0369    1.43 \n#> 3 0.0676 0.250    0.160    0.270   1.00      0.639\n#> 4
  0.160  0.168    0.180    0.641   0.671     0.720\n#> 5 0.439  0.376    0.433    1.76
  \   1.51      1.73 \n#> # ... with 95 more rows\n```\n\n## Filter\n\n`filter_all()`
  is the most useful of the three `filter()` variants. You\nuse it conjunction with
  `all_vars()` or `any_vars()` depending on\nwhether or not you want rows where all
  variables meet the criterion, or\nwhere just one variable meets it.\n\nIt’s particularly
  useful finding missing values:\n\n``` r\nlibrary(nycflights13)\n\n# Rows where any
  value is missing\nfilter_all(weather, any_vars(is.na(.)))\n#> # A tibble: 3,109
  x 15\n#>   origin  year month   day  hour  temp  dewp humid wind… wind… wind… prec…\n#>
  \  <chr>  <dbl> <dbl> <int> <int> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n#>
  1 EWR     2013  1.00     1    17  39.2  28.4  64.9   270 16.1  18.5      0\n#> 2
  EWR     2013  1.00     1    18  39.2  28.4  64.9   330 15.0  17.2      0\n#> 3 EWR
  \    2013  1.00     3    16  30.9  14.0  49.0    NA  4.60  5.30     0\n#> 4 EWR
  \    2013  1.00     6    10  33.8  30.2  86.5   210  4.60  5.30     0\n#> 5 EWR
  \    2013  1.00     6    12  33.8  32.0  93.0   220  9.21 10.6      0\n#> # ...
  with 3,104 more rows, and 3 more variables: pressure <dbl>, visib\n#> #   <dbl>,
  time_hour <dttm>\n\n# Rows where all wind variables are missing\nfilter_at(weather,
  vars(starts_with(\"wind\")), all_vars(is.na(.)))\n#> # A tibble: 3 x 15\n#>   origin
  \ year month   day  hour  temp  dewp humid wind… wind… wind… prec…\n#>   <chr>  <dbl>
  <dbl> <int> <int> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n#> 1 EWR     2013  3.00
  \   27    21  52.0  19.0  27.0    NA    NA    NA     0\n#> 2 JFK     2013  7.00
  \    4    10  73.0  71.1  93.5    NA    NA    NA     0\n#> 3 JFK     2013  7.00
  \   20    10  81.0  71.1  71.9    NA    NA    NA     0\n#> # ... with 3 more variables:
  pressure <dbl>, visib <dbl>, time_hour <dttm>\n```\n"
